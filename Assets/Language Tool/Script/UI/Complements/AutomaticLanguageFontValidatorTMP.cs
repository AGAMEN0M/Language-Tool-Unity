/*
 * ---------------------------------------------------------------------------
 * Description: Automatically validates and updates a TMP Text component's font
 *              to ensure all characters in the current language are supported.
 * Author: Lucas Gomes Cecchini
 * Pseudonym: AGAMENOM
 * ---------------------------------------------------------------------------
*/

using System.Collections.Generic;
using UnityEngine;
using TMPro;

using LanguageTools;
using static LanguageTools.LanguageFileManager;

/// <summary>
/// Validates a TextMeshPro Text component's font against displayed text, replacing the font or fallback language name if necessary.
/// </summary>
[AddComponentMenu("Language/UI/Complements/Automatic Language Font Validator (TMP)")]
public class AutomaticLanguageFontValidatorTMP : MonoBehaviour
{
    [Header("Target Text to Monitor")]
    [SerializeField] private TMP_Text textComponent; // Target TMP_Text component to monitor and validate font characters for.

    [Header("Enable language fallback name resolution")]
    [SerializeField] private bool isLanguageManager; // Whether to allow replacing native names with fallback names based on supported languages.

    private List<LanguageAvailable> supportedLanguages; // List of languages available from settings, used for fallback logic.
    private LanguageSettingsData localizationSettings; // Loaded localization configuration data including TMP font settings.

    private string lastValidatedText; // Stores the last validated text to avoid redundant checks.

    /// <summary> Loads language settings and initializes the validator. </summary>
    private void Start()
    {
        if (textComponent == null)
        {
            Debug.LogError("AutomaticLanguageFontValidatorTMP: TextComponent is not assigned.", this);
            return;
        }

        localizationSettings = LoadLanguageSettings();
        if (localizationSettings == null)
        {
            Debug.LogError("AutomaticLanguageFontValidatorTMP: Failed to load LanguageSettingsData.", this);
            return;
        }

        // Load available languages if fallback logic is enabled.
        if (isLanguageManager)
        {
            supportedLanguages = localizationSettings.availableLanguages;
        }

        ValidateFontSupport(textComponent.text); // Perform an initial validation of the current text.
    }

    /// <summary>
    /// Continuously checks for text changes and re-validates font support when needed.
    /// </summary>
    private void Update()
    {
        if (textComponent == null || localizationSettings == null) return;

        // Use textComponent's internal string reference for comparison to avoid string allocation.
        string currentText = textComponent.text;
        if (!ReferenceEquals(currentText, lastValidatedText))
        {
            lastValidatedText = currentText;
            ValidateFontSupport(currentText);
        }
    }

    /// <summary>
    /// Validates that the font supports all characters in the provided text.
    /// Falls back to alternate fonts or language names as necessary.
    /// </summary>
    /// <param name="text">The text to validate.</param>
    private void ValidateFontSupport(string text)
    {
        if (textComponent == null || localizationSettings == null || localizationSettings.fontListData == null)
        {
            Debug.LogWarning("AutomaticLanguageFontValidatorTMP: Missing textComponent or font list.");
            return;
        }

        var currentFont = textComponent.font;
        var fallbackFonts = localizationSettings.fontListDataTMP.TMPFontList;

        // Check if current font supports all characters.
        bool isCurrentFontValid = true;
        foreach (char c in text)
        {
            if (!currentFont.HasCharacter(c))
            {
                isCurrentFontValid = false;
                break;
            }
        }

        if (isCurrentFontValid) return; // Current font is valid, no need to change.

        // Try each fallback font to see if any supports all characters.
        foreach (var fallbackFont in fallbackFonts)
        {
            if (fallbackFont == null) continue;

            bool fontSupportsAll = true;
            foreach (char c in text)
            {
                if (!fallbackFont.HasCharacter(c))
                {
                    fontSupportsAll = false;
                    break;
                }
            }

            if (fontSupportsAll)
            {
                textComponent.font = fallbackFont;
                Debug.LogWarning($"AutomaticLanguageFontValidatorTMP: Applied fallback font '{fallbackFont.name}'.", this);
                return;
            }
        }

        // If no font supports all characters, fallback to language name.
        if (isLanguageManager)
        {
            var matchingLanguage = supportedLanguages.Find(lang => lang.nativeName == text);
            if (matchingLanguage != null)
            {
                textComponent.text = matchingLanguage.name;
                Debug.LogWarning($"AutomaticLanguageFontValidatorTMP: Unsupported characters detected. Replaced native name with fallback name: '{matchingLanguage.name}'.", this);
            }
        }
    }
}